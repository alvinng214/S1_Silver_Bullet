//@version=6
library("MirPapa_Library_ICT")
import goodia/MirPapa_Handler_HTF/2 as htf

////////////////////////////////////////////////////////////////////////////////
// 구조체 정의
////////////////////////////////////////////////////////////////////////////////

// @type BoxData
// @field _type 박스 타입 (fob, fvg, sweep, rb, custom 등)
// @field _breachMode 돌파 처리 방식
//        - "both": 상단과 하단 모두 돌파해야 종료
//        - "directionalHighLow": 방향에 따라 high/low 돌파 체크 (isBull=true: 먼저 상단 돌파 후 하단 돌파 시 종료)
//        - "directionalClose": 방향에 따라 close 돌파 체크 (isBull=true: 먼저 상단 돌파 후 하단 돌파 시 종료)
// @field _isBull 상승(true) 또는 하락(false) 방향
export type BoxData
    string _type
    string _breachMode
    bool   _isBull
    box    _box
    line   _line
    float  _boxTop
    float  _boxBot
    float  _boxMid
    bool   _topBreached
    bool   _bottomBreached
    int    _breakCount
    int    _createdBar

export type HTFCache
    string _timeframe
    int _lastBarIndex
    bool _isNewBar
    int _barIndex
    float _open
    float _high
    float _low
    float _close
    float _open1
    float _close1
    float _high1
    float _low1
    float _open2
    float _close2
    float _high2
    float _low2
    float _high3
    float _low3
    int _time1
    int _time2

////////////////////////////////////////////////////////////////////////////////
// 내부 함수 (Private)
////////////////////////////////////////////////////////////////////////////////

// 조건 체크 내부 함수
isConditionFOB(bool _isBull, float _pricePrev, float _priceNow) =>
    _isBull ? _priceNow > _pricePrev : _pricePrev > _priceNow

isConditionFVG(bool _isBull, float _pricePrev, float _priceNow) =>
    _isBull ? _priceNow > _pricePrev : _pricePrev > _priceNow

isConditionSweep(float _high2, float _high1, float _high0, float _low2, float _low1, float _low0) =>
    _swingHigh = _high2 < _high1 and _high1 > _high0
    _swingLow = _low2 > _low1 and _low1 < _low0
    _swingHigh and _swingLow

isConditionRB(bool _isBull, float _open1, float _close1, float _high1, float _low1, float _open0, float _close0, float _low2, float _low3, float _high2, float _high3) =>
    if _isBull
        // 상승 RB: candle1=음봉 and candle0=양봉 and low3>low1 and low2>low1 and close1*1.001>open0 and open1<close0
        _candle1Bear = _close1 < _open1
        _candle0Bull = _close0 > _open0
        _lowFilter = _low3 > _low1 and _low2 > _low1
        _priceCondition = _close1 * 1.001 > _open0 and _open1 < _close0
        _candle1Bear and _candle0Bull and _lowFilter and _priceCondition
    else
        // 하락 RB: candle1=양봉 and candle0=음봉 and high3<high1 and high2<high1 and close1*0.999<open0 and open1>close0
        _candle1Bull = _close1 > _open1
        _candle0Bear = _close0 < _open0
        _highFilter = _high3 < _high1 and _high2 < _high1
        _priceCondition = _close1 * 0.999 < _open0 and _open1 > _close0
        _candle1Bull and _candle0Bear and _highFilter and _priceCondition

isConditionSOB(bool _isBull, float _open2, float _close1, float _open1, float _close0) =>
    if _isBull
        // 상승 SOB: 양봉2 => 음봉1 => 양봉0
        // open2 > close1 (양봉2 open이 음봉1 close보다 높다)
        // open1 < close0 (음봉1 open이 양봉0 close보다 낮다)
        _open2 > _close1 and _open1 < _close0
    else
        // 하락 SOB: 음봉2 => 양봉1 => 음봉0
        // open2 < close1 (음봉2 open이 양봉1 close보다 낮다)
        // open1 > close0 (양봉1 open이 음봉0 close보다 높다)
        _open2 < _close1 and _open1 > _close0

// 박스 생성 내부 함수
createBoxInternal(string _type, string _breachMode, bool _isBull, bool _useLine, float _top, float _bot, int _left, int _right, string _xloc, color _colorBG, color _colorBD, color _colorText, string _text) =>
    if na(_top) or na(_bot)
        [false, na]
    else
        _box = box.new(_left, _top, _right, _bot, xloc = _xloc, border_color = _colorBD, bgcolor = _colorBG, text = _text, text_color = _colorText, text_halign = text.align_right)
        _line = _useLine ? line.new(_left, (_top + _bot) * 0.5, _right, (_top + _bot) * 0.5, xloc = _xloc, color = _colorBD, width = 1) : na
        _boxMid = (_top + _bot) * 0.5
        _data = BoxData.new(_type, _breachMode, _isBull, _box, _line, _top, _bot, _boxMid, false, false, 0, bar_index)
        [true, _data]

// 박스 데이터 계산 내부 함수 (offset 0 - 현재 봉)
calculateBoxData0(string _tf) =>
    _isCurrentTF = _tf == timeframe.period
    if _isCurrentTF
        [time, time, high, low, bar_index]
    else
        [int(request.security(syminfo.tickerid, _tf, time)), time, request.security(syminfo.tickerid, _tf, high), request.security(syminfo.tickerid, _tf, low), int(htf.GetHTFrevised(_tf))]

// 박스 데이터 계산 내부 함수 (offset 1)
calculateBoxData1(string _tf) =>
    _isCurrentTF = _tf == timeframe.period
    if _isCurrentTF
        [time[1], time, high[1], low[1], bar_index]
    else
        [int(request.security(syminfo.tickerid, _tf, time[1])), time, request.security(syminfo.tickerid, _tf, high[1]), request.security(syminfo.tickerid, _tf, low[1]), int(htf.GetHTFrevised(_tf))]

// 박스 데이터 계산 내부 함수 (offset 2)
calculateBoxData2(string _tf) =>
    _isCurrentTF = _tf == timeframe.period
    if _isCurrentTF
        [time[2], time, high[2], low[2], bar_index]
    else
        [int(request.security(syminfo.tickerid, _tf, time[2])), time, request.security(syminfo.tickerid, _tf, high[2]), request.security(syminfo.tickerid, _tf, low[2]), int(htf.GetHTFrevised(_tf))]

// 박스 데이터 계산 내부 함수 (offset 3)
calculateBoxData3(string _tf) =>
    _isCurrentTF = _tf == timeframe.period
    if _isCurrentTF
        [time[3], time, high[3], low[3], bar_index]
    else
        [int(request.security(syminfo.tickerid, _tf, time[3])), time, request.security(syminfo.tickerid, _tf, high[3]), request.security(syminfo.tickerid, _tf, low[3]), int(htf.GetHTFrevised(_tf))]

// 돌파 체크 내부 함수
updateBoxBreak(BoxData _data, float _currentHigh, float _currentLow, float _currentClose, int _maxBreakCount) =>
    _newTopBreached = _data._topBreached or (_currentHigh > _data._boxTop)
    _newBottomBreached = _data._bottomBreached or (_currentLow < _data._boxBot)
    
    _breachMode = str.lower(_data._breachMode)
    
    if _breachMode == "directionalhighlow"
        // 방향성 돌파 (High/Low): 먼저 예상 방향 돌파 확인 후 반대 방향 돌파 시 카운트
        if _data._isBull
            // 상승 박스: 먼저 상단 돌파(위로) 확인 → 그 다음 하단 돌파(아래로) 시 카운트
            if _currentHigh > _data._boxTop
                _data._topBreached := true
            
            if _data._topBreached and _currentLow < _data._boxBot
                _data._breakCount := _data._breakCount + 1
                _data._topBreached := false
                _data._bottomBreached := false
        else
            // 하락 박스: 먼저 하단 돌파(아래로) 확인 → 그 다음 상단 돌파(위로) 시 카운트
            if _currentLow < _data._boxBot
                _data._bottomBreached := true
            
            if _data._bottomBreached and _currentHigh > _data._boxTop
                _data._breakCount := _data._breakCount + 1
                _data._topBreached := false
                _data._bottomBreached := false
    else if _breachMode == "directionalclose"
        // 방향성 돌파 (Close): 먼저 예상 방향 돌파 확인 후 반대 방향 돌파 시 카운트
        if _data._isBull
            // 상승 박스: 먼저 상단 돌파(위로) 확인 → 그 다음 하단 돌파(아래로) 시 카운트
            if _currentClose > _data._boxTop
                _data._topBreached := true
            
            if _data._topBreached and _currentClose < _data._boxBot
                _data._breakCount := _data._breakCount + 1
                _data._topBreached := false
                _data._bottomBreached := false
        else
            // 하락 박스: 먼저 하단 돌파(아래로) 확인 → 그 다음 상단 돌파(위로) 시 카운트
            if _currentClose < _data._boxBot
                _data._bottomBreached := true
            
            if _data._bottomBreached and _currentClose > _data._boxTop
                _data._breakCount := _data._breakCount + 1
                _data._topBreached := false
                _data._bottomBreached := false
    else if _breachMode == "sobclose"
        // SOB 돌파 (Close): 즉시 반대 방향 돌파 체크
        if _data._isBull
            // 상승 박스: bottom 종가 돌파 시 즉시 카운트
            if _currentClose < _data._boxBot
                _data._breakCount := _data._breakCount + 1
        else
            // 하락 박스: top 종가 돌파 시 즉시 카운트
            if _currentClose > _data._boxTop
                _data._breakCount := _data._breakCount + 1
    else
        // both: 양쪽 모두 돌파해야 종료
        if _newTopBreached and _newBottomBreached and not (_data._topBreached and _data._bottomBreached)
            _data._breakCount := _data._breakCount + 1
            _data._topBreached := false
            _data._bottomBreached := false
        else
            _data._topBreached := _newTopBreached
            _data._bottomBreached := _newBottomBreached
    
    _data._breakCount >= _maxBreakCount

// 박스 종료 처리
finalizeBox(BoxData _data, color _colorClose) =>
    if not na(_data._box)
        box.set_border_color(_data._box, _colorClose)
        box.set_bgcolor(_data._box, _colorClose)
        box.set_text_color(_data._box, _colorClose)
    if not na(_data._line)
        line.set_color(_data._line, _colorClose)
    _data

// @function GetHTFrevised
// @description Retrieve a specific bar value from a Higher Time Frame (HTF) series.
// @param _tf string    The target HTF string (examples: "60", "1D").
// @param _case string  Case string determining which OHLC value to request.
// @return float        Returns the requested HTF value or na if _case does not match.
export GetHTFrevised(string _tf, string _case) =>
    htf.GetHTFrevised(_tf, _case)

export GetHTFrevised(string _tf) =>
    htf.GetHTFrevised(_tf)

// @function GetHTFoffsetToLTFoffset
// @description Adjust an HTF offset to an LTF offset by calculating the ratio of timeframes.
// @param _offset int         The HTF bar offset (0 means current HTF bar).
// @param _chartTf string     The current chart's timeframe (e.g., "5", "15", "1D").
// @param _htfTf string       The High Time Frame string (e.g., "60", "1D").
// @return int                The corresponding LTF bar index. Returns 0 if the result is negative.
export GetHTFoffsetToLTFoffset(int _offset, string _chartTf, string _htfTf) =>
    htf.GetHTFoffsetToLTFoffset(_offset, _chartTf, _htfTf)

// @function GetHtfFromLabel
// @description Convert a Korean HTF label into a Pine Script timeframe string.
// @param _label string    The Korean label (e.g., "5분", "1시간").
// @return string          Returns the corresponding Pine Script timeframe (e.g., "5", "60").
export GetHtfFromLabel(string _label) =>
    htf.GetHTFfromLabel(_label)

// @function IsChartTFcomparisonHTF
// @description Determine whether a given HTF is greater than or equal to the current chart timeframe.
// @param _chartTf string  Current chart timeframe (e.g., "5", "15", "1D").
// @param _htfTf string    HTF timeframe (e.g., "60", "1D").
// @return bool            True if HTF ≥ chartTF, false otherwise.
export IsChartTFcomparisonHTF(string _chartTf, string _htfTf) =>
    htf.IsChartTFcomparisonHTF(_chartTf, _htfTf)


////////////////////////////////////////////////////////////////////////////////
// Public API (5개 함수만 export)
////////////////////////////////////////////////////////////////////////////////

// @function IsCondition
// @description FOB, FVG 조건 체크.\
// _boxType: "fob"(Fair Order Block) 또는 "fvg"(Fair Value Gap).\
// _isBull: true(상승 패턴), false(하락 패턴).\
// 상승 시 현재 가격이 이전 가격보다 높으면 true, 하락 시 이전 가격이 현재 가격보다 높으면 true 반환.
// @param _boxType 박스 타입 ("fob", "fvg")
// @param _isBull 상승(true) 또는 하락(false)
// @param _pricePrev 이전 가격
// @param _priceNow 현재 가격
// @returns bool 조건 만족 여부
export IsCondition(string _boxType, bool _isBull, float _pricePrev, float _priceNow) =>
    switch _boxType
        "fob" => isConditionFOB(_isBull, _pricePrev, _priceNow)
        "fvg" => isConditionFVG(_isBull, _pricePrev, _priceNow)
        => false

// @function IsCondition
// @description Sweep 조건 체크 (Swing High/Low 동시 발생).\
// _boxType: "sweep" 또는 "breachBoth".\
// 조건: high2 < high1 > high0 (Swing High) AND low2 > low1 < low0 (Swing Low).\
// 중간 캔들이 양쪽보다 높고 낮은 지점을 동시에 형성할 때 true 반환.
// @param _boxType 박스 타입 ("sweep", "breachBoth")
// @param _high2, _high1, _high0 최근 3개 캔들의 high
// @param _low2, _low1, _low0 최근 3개 캔들의 low
// @returns bool 조건 만족 여부
export IsCondition(string _boxType, float _high2, float _high1, float _high0, float _low2, float _low1, float _low0) =>
    (_boxType == "sweep" or _boxType == "breachBoth") ? isConditionSweep(_high2, _high1, _high0, _low2, _low1, _low0) : false

// @function IsCondition
// @description RB (Rejection Block) 조건 체크.\
// _boxType: "rb" (Rejection Block).\
// 상승 RB: candle1=음봉, candle0=양봉, low3>low1 AND low2>low1, close1*1.001>open0, open1<close0.\
// 하락 RB: candle1=양봉, candle0=음봉, high3<high1 AND high2<high1, close1*0.999<open0, open1>close0.\
// 이전 캔들의 거부 후 현재 캔들이 반대 방향으로 전환될 때 true 반환.
// @param _boxType 박스 타입 ("rb")
// @param _isBull 상승(true) 또는 하락(false)
// @param _open1, _close1, _high1, _low1 이전 캔들 OHLC
// @param _open0, _close0 현재 캔들 OC
// @param _low2, _low3, _high2, _high3 2-3개 이전 캔들의 high/low
// @returns bool 조건 만족 여부
export IsCondition(string _boxType, bool _isBull, float _open1, float _close1, float _high1, float _low1, float _open0, float _close0, float _low2, float _low3, float _high2, float _high3) =>
    _boxType == "rb" ? isConditionRB(_isBull, _open1, _close1, _high1, _low1, _open0, _close0, _low2, _low3, _high2, _high3) : false

// @function IsCondition
// @description SOB (Strong Order Block) 조건 체크.\
// _boxType: "sob" (Strong Order Block).\
// 상승 SOB: 양봉2 => 음봉1 => 양봉0, open2 > close1 AND open1 < close0.\
// 하락 SOB: 음봉2 => 양봉1 => 음봉0, open2 < close1 AND open1 > close0.\
// 3개 캔들 패턴으로 강한 주문 블록 형성 시 true 반환.
// @param _boxType 박스 타입 ("sob")
// @param _isBull 상승(true) 또는 하락(false)
// @param _open2 2개 이전 캔들 open
// @param _close1 1개 이전 캔들 close
// @param _open1 1개 이전 캔들 open
// @param _close0 현재 캔들 close
// @returns bool 조건 만족 여부
export IsCondition(string _boxType, bool _isBull, float _open2, float _close1, float _open1, float _close0) =>
    _boxType == "sob" ? isConditionSOB(_isBull, _open2, _close1, _open1, _close0) : false

// @function CreateBox
// @description 박스 생성 (breachMode 자동 결정).\
// _boxType: "fob", "rb", "custom" → directionalHighLow, 나머지 → both.\
// _tf: 시간대 (timeframe.period 또는 HTF).\
// _isBull: true(상승 박스), false(하락 박스).\
// _cache: HTF 사용 시 필수, CurrentTF는 na.\
// 반환: [성공 여부(bool), 박스 데이터(BoxData)].
// @param _boxType 박스 타입
// @param _tf 시간대
// @param _isBull 상승(true) 또는 하락(false)
// @param _useLine 중간선 표시 여부
// @param _colorBG 박스 배경색
// @param _colorBD 박스 테두리색
// @param _colorText 텍스트 색상
// @param _cache HTF 캐시 데이터
// @returns [bool, BoxData] 성공 여부와 박스 데이터
export CreateBox(string _boxType, string _tf, bool _isBull, bool _useLine, color _colorBG, color _colorBD, color _colorText, HTFCache _cache) =>
    _isCurrentTF = _tf == timeframe.period
    
    [_leftTime, _rightTime, _top, _bottom, _htfBarIndex] = if _boxType == "fvg"
        // FVG 특별 처리: candle1 위치, 상승=high2~low / 하락=low2~high
        if _isCurrentTF
            [time[1], time, _isBull ? high[2] : high, _isBull ? low : low[2], bar_index]
        else
            [_cache._time1, time, _isBull ? _cache._high2 : _cache._high, _isBull ? _cache._low : _cache._low2, _cache._barIndex]
    else if _boxType == "sob"
        // SOB 특별 처리: candle1 위치, 박스 크기는 candle1의 몸통
        if _isCurrentTF
            [time[1], time, math.max(open[1], close[1]), math.min(open[1], close[1]), bar_index]
        else
            [_cache._time1, time, math.max(_cache._open1, _cache._close1), math.min(_cache._open1, _cache._close1), _cache._barIndex]
    else if _isCurrentTF
        // CurrentTF는 직접 계산
        switch _boxType
            "rb" => [time, time, high, low, bar_index]
            "sweep" => [time[1], time, high[1], low[1], bar_index]
            "breachBoth" => [time, time, high, low, bar_index]
            "custom" => [time, time, high, low, bar_index]
            => [time[2], time, high[2], low[2], bar_index]
    else
        // HTF는 캐싱된 데이터 사용
        switch _boxType
            "rb" => [int(_cache._time1), time, _cache._high, _cache._low, _cache._barIndex]
            "sweep" => [_cache._time1, time, _cache._high1, _cache._low1, _cache._barIndex]
            "breachBoth" => [int(_cache._time1), time, _cache._high, _cache._low, _cache._barIndex]
            "custom" => [int(_cache._time1), time, _cache._high, _cache._low, _cache._barIndex]
            => [_cache._time2, time, _cache._high2, _cache._low2, _cache._barIndex]
    
    // breachMode 자동 결정
    _breachMode = switch _boxType
        "fob" => "directionalHighLow"
        "rb" => "directionalHighLow"
        "sob" => "sobClose"
        "custom" => "directionalHighLow"
        => "both"
    
    _text = _tf + " " + str.upper(_boxType)
    createBoxInternal(_boxType, _breachMode, _isBull, _useLine, _top, _bottom, _leftTime, _rightTime, xloc.bar_time, _colorBG, _colorBD, _colorText, _text)

// @function CreateBox
// @description 박스 생성 (커스텀 텍스트 지원, breachMode 자동 결정).\
// _boxType: "fob", "rb", "custom" → directionalHighLow, 나머지 → both.\
// _customText: 박스에 표시할 텍스트 (비어있으면 "시간대 박스타입" 형식으로 자동 생성).\
// _isBull: true(상승 박스), false(하락 박스).\
// 반환: [성공 여부(bool), 박스 데이터(BoxData)].
// @param _boxType 박스 타입
// @param _tf 시간대
// @param _isBull 상승(true) 또는 하락(false)
// @param _useLine 중간선 표시 여부
// @param _colorBG 박스 배경색
// @param _colorBD 박스 테두리색
// @param _colorText 텍스트 색상
// @param _cache HTF 캐시 데이터
// @param _customText 커스텀 텍스트
// @returns [bool, BoxData] 성공 여부와 박스 데이터
export CreateBox(string _boxType, string _tf, bool _isBull, bool _useLine, color _colorBG, color _colorBD, color _colorText, HTFCache _cache, string _customText) =>
    _isCurrentTF = _tf == timeframe.period
    
    [_leftTime, _rightTime, _top, _bottom, _htfBarIndex] = if _boxType == "fvg"
        // FVG 특별 처리: candle1 위치, 상승=high2~low / 하락=low2~high
        if _isCurrentTF
            [time[1], time, _isBull ? high[2] : high, _isBull ? low : low[2], bar_index]
        else
            [_cache._time1, time, _isBull ? _cache._high2 : _cache._high, _isBull ? _cache._low : _cache._low2, _cache._barIndex]
    else if _boxType == "sob"
        // SOB 특별 처리: candle1 위치, 박스 크기는 candle1의 몸통
        if _isCurrentTF
            [time[2], time, math.max(open, close), math.min(open, close), bar_index]
        else
            [_cache._time1, time, math.max(_cache._open1, _cache._close1), math.min(_cache._open1, _cache._close1), _cache._barIndex]
    else if _isCurrentTF
        // CurrentTF는 직접 계산
        switch _boxType
            "rb" => [time, time, high, low, bar_index]
            "sweep" => [time[1], time, high[1], low[1], bar_index]
            "breachBoth" => [time, time, high, low, bar_index]
            "custom" => [time, time, high, low, bar_index]
            => [time[2], time, high[2], low[2], bar_index]
    else
        // HTF는 캐싱된 데이터 사용
        switch _boxType
            "rb" => [int(_cache._time1), time, _cache._high, _cache._low, _cache._barIndex]
            "sweep" => [_cache._time1, time, _cache._high1, _cache._low1, _cache._barIndex]
            "breachBoth" => [int(_cache._time1), time, _cache._high, _cache._low, _cache._barIndex]
            "custom" => [int(_cache._time1), time, _cache._high, _cache._low, _cache._barIndex]
            => [_cache._time2, time, _cache._high2, _cache._low2, _cache._barIndex]
    
    // breachMode 자동 결정
    _breachMode = switch _boxType
        "fob" => "directionalHighLow"
        "rb" => "directionalHighLow"
        "sob" => "sobClose"
        "custom" => "directionalHighLow"
        => "both"
    
    _text = na(_customText) or _customText == "" ? (_tf + " " + str.upper(_boxType)) : _customText
    createBoxInternal(_boxType, _breachMode, _isBull, _useLine, _top, _bottom, _leftTime, _rightTime, xloc.bar_time, _colorBG, _colorBD, _colorText, _text)

// @function CreateBox
// @description 박스 생성 (breachMode 명시적 지정).\
// _breachMode: "both"(양쪽 모두 돌파), "directionalHighLow"(방향성 high/low 돌파), "directionalClose"(방향성 close 돌파).\
// _isBull: true(상승 박스), false(하락 박스).\
// _customText: 박스에 표시할 텍스트 (비어있으면 "시간대 박스타입" 형식으로 자동 생성).\
// 반환: [성공 여부(bool), 박스 데이터(BoxData)].
// @param _boxType 박스 타입 (fob, fvg, sweep, rb, custom 등)
// @param _breachMode 돌파 처리 방식: "both" (양쪽 모두), "directionalHighLow" (방향성 high/low), "directionalClose" (방향성 close)
// @param _tf 시간대
// @param _isBull 상승(true) 또는 하락(false) 방향
// @param _useLine 중간선 표시 여부
// @param _colorBG 박스 배경색
// @param _colorBD 박스 테두리색
// @param _colorText 텍스트 색상
// @param _cache HTF 캐시 데이터 (CurrentTF는 na)
// @param _customText 커스텀 텍스트 (비어있으면 자동 생성)
// @returns [bool, BoxData] 성공 여부와 박스 데이터
export CreateBox(string _boxType, string _breachMode, string _tf, bool _isBull, bool _useLine, color _colorBG, color _colorBD, color _colorText, HTFCache _cache, string _customText) =>
    _isCurrentTF = _tf == timeframe.period
    
    [_leftTime, _rightTime, _top, _bottom, _htfBarIndex] = if _boxType == "fvg"
        // FVG 특별 처리: candle1 위치, 상승=high2~low / 하락=low2~high
        if _isCurrentTF
            [time[1], time, _isBull ? high[2] : high, _isBull ? low : low[2], bar_index]
        else
            [_cache._time1, time, _isBull ? _cache._high2 : _cache._high, _isBull ? _cache._low : _cache._low2, _cache._barIndex]
    else if _boxType == "sob"
        // SOB 특별 처리: candle1 위치, 박스 크기는 candle1의 몸통
        if _isCurrentTF
            [time[1], time, math.max(open[1], close[1]), math.min(open[1], close[1]), bar_index]
        else
            [_cache._time1, time, math.max(_cache._open1, _cache._close1), math.min(_cache._open1, _cache._close1), _cache._barIndex]
    else if _isCurrentTF
        // CurrentTF는 직접 계산
        switch _boxType
            "rb" => [time, time, high, low, bar_index]
            "sweep" => [time[1], time, high[1], low[1], bar_index]
            "breachBoth" => [time, time, high, low, bar_index]
            "custom" => [time, time, high, low, bar_index]
            => [time[2], time, high[2], low[2], bar_index]
    else
        // HTF는 캐싱된 데이터 사용
        switch _boxType
            "rb" => [int(_cache._time1), time, _cache._high, _cache._low, _cache._barIndex]
            "sweep" => [_cache._time1, time, _cache._high1, _cache._low1, _cache._barIndex]
            "breachBoth" => [int(_cache._time1), time, _cache._high, _cache._low, _cache._barIndex]
            "custom" => [int(_cache._time1), time, _cache._high, _cache._low, _cache._barIndex]
            => [_cache._time2, time, _cache._high2, _cache._low2, _cache._barIndex]
    
    _text = na(_customText) or _customText == "" ? (_tf + " " + str.upper(_boxType)) : _customText
    createBoxInternal(_boxType, _breachMode, _isBull, _useLine, _top, _bottom, _leftTime, _rightTime, xloc.bar_time, _colorBG, _colorBD, _colorText, _text)

// @function CreateCustomBox
// @description 완전히 유연한 커스텀 박스 생성.\
// 사용자가 박스 위치(top, bottom, left, right), breach mode, 모든 파라미터를 직접 지정.\
// 조건 체크는 사용자 스크립트에서 수행하고, 이 함수는 박스 생성만 담당.\
// 새로운 박스 타입 추가 시 라이브러리 수정 없이 사용 가능.
// @param _boxType 박스 타입 (사용자 정의 문자열)
// @param _breachMode 돌파 처리 방식: "both", "directionalHighLow", "directionalClose", "sobClose"
// @param _isBull 상승(true) 또는 하락(false) 방향
// @param _top 박스 상단 가격
// @param _bottom 박스 하단 가격
// @param _left 박스 시작 시간 (xloc.bar_time 사용)
// @param _right 박스 종료 시간 (xloc.bar_time 사용)
// @param _useLine 중간선 표시 여부
// @param _colorBG 박스 배경색
// @param _colorBD 박스 테두리색
// @param _colorText 텍스트 색상
// @param _text 박스에 표시할 텍스트
// @returns [bool, BoxData] 성공 여부와 박스 데이터
export CreateCustomBox(string _boxType, string _breachMode, bool _isBull, float _top, float _bottom, int _left, int _right, bool _useLine, color _colorBG, color _colorBD, color _colorText, string _text) =>
    createBoxInternal(_boxType, _breachMode, _isBull, _useLine, _top, _bottom, _left, _right, xloc.bar_time, _colorBG, _colorBD, _colorText, _text)

// @function ProcessBoxDatas
// @description 박스 확장 및 돌파 처리.\
// 열린 박스들을 현재 bar까지 확장하고, 돌파 조건 체크.\
// _closeCount: 돌파 횟수 (이 횟수만큼 돌파 시 박스 종료).\
// breachMode에 따라 돌파 체크 방식 다름 (both/directionalHighLow/directionalClose).\
// 종료된 박스는 _closedBoxes로 이동하고 _colorClose 색상 적용.\
// barstate.islast와 barstate.isconfirmed에서 호출 권장.
// @param _openBoxes 열린 박스 배열
// @param _closedBoxes 닫힌 박스 배열
// @param _useMidLine 중간선 표시 여부
// @param _closeCount 돌파 카운트 (이 횟수만큼 돌파 시 종료)
// @param _colorClose 종료된 박스 색상
// @param _currentBarIndex 현재 bar_index
// @param _currentLow 현재 low
// @param _currentHigh 현재 high
// @param _currentTime 현재 time
// @returns bool 항상 true
export ProcessBoxDatas(array<BoxData> _openBoxes, array<BoxData> _closedBoxes, bool _useMidLine, int _closeCount, color _colorClose, int _currentBarIndex, float _currentLow, float _currentHigh, int _currentTime) =>
    if array.size(_openBoxes) > 0
        for i = array.size(_openBoxes) - 1 to 0 by 1
            _data = array.get(_openBoxes, i)
            
            _rightValue = box.get_right(_data._box)
            _isTimeMode = na(_rightValue) or _rightValue > 1e10
            box.set_right(_data._box, _isTimeMode ? _currentTime : _currentBarIndex)
            if _useMidLine and not na(_data._line)
                line.set_x2(_data._line, _isTimeMode ? _currentTime : _currentBarIndex)
            
            _shouldTerminate = updateBoxBreak(_data, _currentHigh, _currentLow, close, _closeCount)
            array.set(_openBoxes, i, _data)
            
            if _shouldTerminate
                _data := finalizeBox(_data, _colorClose)
                array.push(_closedBoxes, _data)
                array.remove(_openBoxes, i)
    true

// @function UpdateHTFCache
// @description HTF 데이터 캐싱 (성능 최적화).\
// HTF의 OHLC 데이터를 캐싱하여 매 틱마다 request.security 호출 방지.\
// _cache: 기존 캐시 (없으면 na, 첫 호출 시).\
// _tf: 캐싱할 시간대 (예: "60", "1D").\
// 새 bar 또는 bar_index 변경 시에만 업데이트, 그 외에는 기존 캐시 반환.\
// @param _cache 기존 캐시 데이터 (없으면 na)
// @param _tf 시간대
// @returns HTFCache 업데이트된 캐시 데이터
export UpdateHTFCache(HTFCache _cache, string _tf) =>
    _currentBarIndex = bar_index
    _isNewBar = ta.change(time(_tf)) != 0
    
    if na(_cache) or _cache._lastBarIndex != _currentBarIndex or _isNewBar
        HTFCache.new(
             _tf,
             _currentBarIndex,
             _isNewBar,
             int(htf.GetHTFrevised(_tf)),
             htf.GetHTFrevised(_tf, "o"),
             htf.GetHTFrevised(_tf, "h"),
             htf.GetHTFrevised(_tf, "l"),
             htf.GetHTFrevised(_tf, "c"),
             htf.GetHTFrevised(_tf, "o1"),
             htf.GetHTFrevised(_tf, "c1"),
             htf.GetHTFrevised(_tf, "h1"),
             htf.GetHTFrevised(_tf, "l1"),
             htf.GetHTFrevised(_tf, "o2"),
             htf.GetHTFrevised(_tf, "c2"),
             htf.GetHTFrevised(_tf, "h2"),
             htf.GetHTFrevised(_tf, "l2"),
             htf.GetHTFrevised(_tf, "h3"),
             htf.GetHTFrevised(_tf, "l3"),
             int(request.security(syminfo.tickerid, _tf, time[1])),
             int(request.security(syminfo.tickerid, _tf, time[2]))
             )
    else
        _cache

// @function GetTimeframeSettings
// @description 현재 차트 시간대에 맞는 중위/상위 시간대 자동 선택.\
// _currentTF: 현재 차트 시간대 (timeframe.period).\
// 1분~1월 차트별로 적절한 중위/상위 시간대 매핑.\
// 예: 5분 차트 → 중위 15분, 상위 60분.\
// 반환: [중위 시간대(string), 상위 시간대(string)].\
// @param _currentTF 현재 차트 시간대
// @param _midTF1m~_highTF1M 각 시간대별 중위/상위 시간대 설정
// @returns [string, string] [중위 시간대, 상위 시간대]
export GetTimeframeSettings(string _currentTF, string _midTF1m, string _highTF1m, string _midTF5m, string _highTF5m, string _midTF15m, string _highTF15m, string _midTF30m, string _highTF30m, string _midTF60m, string _highTF60m, string _midTF240m, string _highTF240m, string _midTF1D, string _highTF1D, string _midTF1W, string _highTF1W, string _midTF1M, string _highTF1M) =>
    _midTimeframe = switch _currentTF
        '1' => _midTF1m
        '5' => _midTF5m
        '15' => _midTF15m
        '30' => _midTF30m
        '60' => _midTF60m
        '240' => _midTF240m
        '1D' => _midTF1D
        '1W' => _midTF1W
        '1M' => _midTF1M
        => '240'
    
    _highTimeframe = switch _currentTF
        '1' => _highTF1m
        '5' => _highTF5m
        '15' => _highTF15m
        '30' => _highTF30m
        '60' => _highTF60m
        '240' => _highTF240m
        '1D' => _highTF1D
        '1W' => _highTF1W
        '1M' => _highTF1M
        => '1D'
    
    [_midTimeframe, _highTimeframe]
