//@version=6
library("Mirpapa_Lib_Line", overlay = false)

////////////////////////////////////////////////////////////////////////////////
// 구조체 정의
////////////////////////////////////////////////////////////////////////////////

// @type BreachMode
// @field 돌파 처리 방식 상수
export type BreachMode
    string PRICE = "price"           // 가격 돌파
    string CLOSE = "close"           // 종가 돌파

// @type LineData
// @field _breachMode 돌파 처리 방식
// @field _isBull 상승(true) 또는 하락(false) 방향
// @field _line 라인 객체
// @field _price 라인 가격
// @field _text 라인 텍스트
// @field _breached 돌파 여부
// @field _breakCount 돌파 카운트
export type LineData
    string _breachMode
    bool   _isBull
    line   _line
    float  _price
    string _text
    bool   _breached
    int    _breakCount

////////////////////////////////////////////////////////////////////////////////
// 내부 함수 (Private)
////////////////////////////////////////////////////////////////////////////////

// 라인 생성 내부 함수
createLineInternal(string _breachMode, bool _isBull, float _price, int _left, int _right, string _xloc, color _lineColor, int _lineWidth, string _lineStyle, string _text) =>
    if na(_price)
        [false, na]
    else
        _line = line.new(_left, _price, _right, _price, xloc = _xloc, color = _lineColor, width = _lineWidth, style = _lineStyle)
        _data = LineData.new(_breachMode, _isBull, _line, _price, _text, false, 0)
        [true, _data]

// 돌파 체크 내부 함수
updateLineBreak(LineData _data, float _currentHigh, float _currentLow, float _currentClose, int _maxBreakCount) =>
    var BreachMode bm = BreachMode.new()
    _mode = str.lower(_data._breachMode)
    
    if _mode == str.lower(bm.CLOSE)
        // 종가 돌파
        if _data._isBull
            // 상승: 종가가 라인 아래로 돌파
            if _currentClose < _data._price
                _data._breakCount := _data._breakCount + 1
                _data._breached := true
        else
            // 하락: 종가가 라인 위로 돌파
            if _currentClose > _data._price
                _data._breakCount := _data._breakCount + 1
                _data._breached := true
    else
        // 기본값: PRICE (고가/저가 돌파)
        if _data._isBull
            // 상승: 저가가 라인 아래로 돌파
            if _currentLow < _data._price
                _data._breakCount := _data._breakCount + 1
                _data._breached := true
        else
            // 하락: 고가가 라인 위로 돌파
            if _currentHigh > _data._price
                _data._breakCount := _data._breakCount + 1
                _data._breached := true
    
    _data._breakCount >= _maxBreakCount

// 라인 종료 처리
finalizeLine(LineData _data, color _colorClose) =>
    if not na(_data._line)
        line.set_color(_data._line, _colorClose)
    _data

////////////////////////////////////////////////////////////////////////////////
// Public API
////////////////////////////////////////////////////////////////////////////////

// @function CreateLine
// @description 라인 생성 (값 전달 방식 - 모든 좌표 직접 지정).\
// 호출자가 모든 좌표와 시간을 계산하여 전달.\
// breachMode: "price"(고가/저가 돌파) 또는 "close"(종가 돌파).\
// @param _breachMode 돌파 처리 방식: "price" 또는 "close"
// @param _isBull 상승(true) 또는 하락(false)
// @param _leftTime 라인 시작 시간
// @param _rightTime 라인 종료 시간
// @param _price 라인 가격
// @param _lineColor 라인 색상
// @param _lineWidth 라인 두께
// @param _lineStyle 라인 스타일 (line.style_solid, line.style_dashed 등)
// @param _text 라인 텍스트
// @returns [bool, LineData] 성공 여부와 라인 데이터
export CreateLine(string _breachMode, bool _isBull, int _leftTime, int _rightTime, float _price, color _lineColor, int _lineWidth, string _lineStyle, string _text) =>
    createLineInternal(_breachMode, _isBull, _price, _leftTime, _rightTime, xloc.bar_time, _lineColor, _lineWidth, _lineStyle, _text)

// @function ProcessLineDatas
// @description 라인 확장 및 돌파 처리.\
// 열린 라인들을 현재 bar까지 확장하고, 돌파 조건 체크.\
// _closeCount: 돌파 횟수 (이 횟수만큼 돌파 시 라인 종료).\
// breachMode에 따라 돌파 체크 방식 다름 (price/close).\
// 종료된 라인은 _closedLines로 이동하고 _colorClose 색상 적용.\
// barstate.islast와 barstate.isconfirmed에서 호출 권장.
// @param _openLines 열린 라인 배열
// @param _closedLines 닫힌 라인 배열
// @param _closeCount 돌파 카운트 (이 횟수만큼 돌파 시 종료)
// @param _colorClose 종료된 라인 색상
// @param _currentBarIndex 현재 bar_index
// @param _currentLow 현재 low
// @param _currentHigh 현재 high
// @param _currentTime 현재 time
// @returns bool 항상 true
export ProcessLineDatas(array<LineData> _openLines, array<LineData> _closedLines, int _closeCount, color _colorClose, int _currentBarIndex, float _currentLow, float _currentHigh, int _currentTime) =>
    if array.size(_openLines) > 0
        for i = array.size(_openLines) - 1 to 0 by 1
            _data = array.get(_openLines, i)
            
            _rightValue = line.get_x2(_data._line)
            _isTimeMode = na(_rightValue) or _rightValue > 1e10
            line.set_x2(_data._line, _isTimeMode ? _currentTime : _currentBarIndex)
            
            _shouldTerminate = updateLineBreak(_data, _currentHigh, _currentLow, close, _closeCount)
            array.set(_openLines, i, _data)
            
            if _shouldTerminate
                _data := finalizeLine(_data, _colorClose)
                array.push(_closedLines, _data)
                array.remove(_openLines, i)
    true
